<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React App - Braintrust AppBuilder Demo</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        #root {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .loading {
            text-align: center;
            padding: 40px;
            color: #555;
            font-size: 16px;
        }
        .error {
            color: #d93f4c;
            padding: 20px;
            border: 1px solid #f5c6cb;
            border-radius: 4px;
            background-color: #f8d7da;
            margin-bottom: 20px;
        }
    </style>
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18",
        "react-dom": "https://esm.sh/react-dom@18?external=react&standalone",
        "react-dom/client": "https://esm.sh/react-dom@18/client?external=react&standalone",
        "styled-components": "https://esm.sh/styled-components@6.x?external=react&standalone",
        "pdfjs-dist": "https://esm.sh/pdfjs-dist@4.10.38?standalone",
        "tesseract.js": "https://esm.sh/tesseract.js@6.0.0?standalone",
        "@zendeskgarden/react-theming": "https://esm.sh/@zendeskgarden/react-theming@9.x?external=react,styled-components&standalone",
        "@zendeskgarden/react-buttons": "https://esm.sh/@zendeskgarden/react-buttons@9.x?external=react,styled-components,@zendeskgarden/react-theming&standalone",
        "@zendeskgarden/react-grid": "https://esm.sh/@zendeskgarden/react-grid@9.x?external=react,styled-components,@zendeskgarden/react-theming&standalone",
        "@zendeskgarden/react-forms": "https://esm.sh/@zendeskgarden/react-forms@9.x?external=react,styled-components,@zendeskgarden/react-theming&standalone",
        "@zendeskgarden/react-tables": "https://esm.sh/@zendeskgarden/react-tables@9.x?external=react,styled-components,@zendeskgarden/react-theming&standalone",
        "@zendeskgarden/react-typography": "https://esm.sh/@zendeskgarden/react-typography@9.x?external=react,styled-components,@zendeskgarden/react-theming&standalone",
        "@zendeskgarden/react-loaders": "https://esm.sh/@zendeskgarden/react-loaders@9.x?external=react,styled-components,@zendeskgarden/react-theming&standalone",
        "@zendeskgarden/react-tags": "https://esm.sh/@zendeskgarden/react-tags@9.x?external=react,styled-components,@zendeskgarden/react-theming&standalone",
        "@zendeskgarden/react-tabs": "https://esm.sh/@zendeskgarden/react-tabs@9.x?external=react,styled-components,@zendeskgarden/react-theming&standalone",
        "@zendeskgarden/react-accordions": "https://esm.sh/@zendeskgarden/react-accordions@9.x?external=react,styled-components,@zendeskgarden/react-theming&standalone",
        "@zendeskgarden/react-tooltips": "https://esm.sh/@zendeskgarden/react-tooltips@9.x?external=react,styled-components,@zendeskgarden/react-theming&standalone",
        "@zendeskgarden/react-modals": "https://esm.sh/@zendeskgarden/react-modals@9.x?external=react,styled-components,@zendeskgarden/react-theming&standalone",
        "@zendeskgarden/react-notifications": "https://esm.sh/@zendeskgarden/react-notifications@9.x?external=react,styled-components,@zendeskgarden/react-theming&standalone",
        "@zendeskgarden/react-pagination": "https://esm.sh/@zendeskgarden/react-pagination@9.x?external=react,styled-components,@zendeskgarden/react-theming&standalone"
      }
    }
    </script>
</head>
<body>
    <div id="root">
        <div class="loading">Loading application...<div id="debug-info" style="color: #999; font-size: 12px; margin-top: 10px;"></div></div>
    </div>

    <!-- CDN Assets from CDN_ASSETS_MAPPING -->

    <script type="module">
      import React from 'react';
      import ReactDOM from 'react-dom/client';
      window.React = React;
      window.ReactDOM = ReactDOM;
    </script>
    
    <!-- esbuild-wasm for bundling -->
    <script src="https://unpkg.com/esbuild-wasm@0.17.19/lib/browser.min.js"></script>
    <script type="text/javascript" src="https://static.zdassets.com/zendesk_app_framework_sdk/2.0/zaf_sdk.min.js"></script>

    <!-- Your React App -->
    <script>
        // Listen for messages containing file data
        function handleMessage(event) {
            console.log("Message received:", event);
            const receivedData = event.data;
            
            // Handle new data structure where files are in data.output.appCode as an object
            let files = null;
            
            // Check for new structure: data.output.appCode (object with filePath keys)
            const appCode = receivedData.data?.output?.appCode;
            if (appCode && typeof appCode === 'object' && !Array.isArray(appCode)) {
                console.log("Detected new appCode structure, converting to file array...");
                // Convert object { "path": "content" } to array [{ args: { filePath, fileContent } }]
                files = Object.entries(appCode).map(([filePath, fileContent]) => ({
                    args: {
                        filePath: filePath,
                        fileContent: fileContent
                    }
                }));
                console.log("Converted files:", files.map(f => f.args.filePath));
            }
            // Fallback to old structure: data.output as array
            else if (Array.isArray(receivedData.data?.output)) {
                files = receivedData.data.output;
                console.log("Using legacy array structure");
            }
            
            if (!files || !Array.isArray(files) || files.length === 0) {
                console.log("No valid files received in message");
                console.log("Received data structure:", JSON.stringify(receivedData, null, 2).substring(0, 500));
                document.getElementById('root').innerHTML = `
                    <div class="error">
                        <h3>Error Loading Application</h3>
                        <p>No valid files received in the message.</p>
                        <p style="font-size: 12px; color: #666;">Check console for data structure details.</p>
                    </div>
                `;
                return;
            }
            
            console.log("Received files:", files.map(f => f.args.filePath));
            
            // Filter out .md and .json files (non-executable)
            const outputFiles = files.filter(file => 
                !file.args.filePath.endsWith('.md') && 
                !file.args.filePath.endsWith('.json')
            );
            
            // Start the bundling process with the received files
            initializeAndBundleApp(outputFiles);
        }

        // Main function to initialize esbuild and bundle the app
        async function initializeAndBundleApp(outputFiles) {
            try {
                console.log("Processing files:", outputFiles.map(f => f.args.filePath));
                
                // Initialize ZAF Client and mock data
                try {
                    console.log("Initializing ZAF client");
                    // Initialize ZAFClient
                    window.zafClient = ZAFClient.init();
                    
                    // Find and use the mock.js file
                    const mockFile = outputFiles.find(file => 
                        file.args.filePath === 'mock.js' || 
                        file.args.filePath.endsWith('/mock.js'));
                    
                    console.log("** Inside Mock File Handling **");
                    if (mockFile) {
                        console.log("Found mock.js file");
                        const mockContent = mockFile.args.fileContent;
                        // Create a new script element to evaluate the mock file
                        const mockScript = document.createElement('script');
                        mockScript.textContent = mockContent;
                        document.head.appendChild(mockScript);
                        console.log("Mock data loaded successfully");
                    } else {
                        console.warn("Could not find mock.js file in outputFiles");
                    }
                } catch (error) {
                    console.error("Error initializing ZAF client:", error);
                }

                // Initialize esbuild-wasm
                console.log("Initializing esbuild...");
                await esbuild.initialize({
                    wasmURL: 'https://unpkg.com/esbuild-wasm@0.17.19/esbuild.wasm',
                    worker: true
                });
                console.log("esbuild initialized successfully");

                // 1) First, load and apply all CSS/styles files
                const styleFiles = outputFiles.filter(file => 
                    file.args.filePath.includes('styles') || 
                    file.args.filePath.endsWith('.css') || 
                    file.args.filePath.includes('styles.js')
                );
                
                console.log('Style files found:', styleFiles.map(f => f.args.filePath));
                console.log('Style file content sample:', styleFiles[0]?.args.fileContent?.substring(0, 100));
                
                styleFiles.forEach(styleFile => {
                    console.log(`Loading styles from: ${styleFile.args.filePath}`);
                    const styleElement = document.createElement('style');
                    styleElement.textContent = styleFile.args.fileContent;
                    document.head.appendChild(styleElement);
                    console.log(`Styles loaded successfully from: ${styleFile.args.filePath}`);
                });
                
                // 2) Create a virtual file system from all the JS/JSX files (not CSS)
                const jsxFiles = outputFiles.filter(file => 
                    file.args.filePath.endsWith('.jsx') || 
                    (file.args.filePath.endsWith('.js') && !file.args.filePath.includes('styles.js'))
                );
                
                console.log('JSX files found:', jsxFiles.map(f => f.args.filePath));
                jsxFiles.forEach(file => {
                    console.log(`${file.args.filePath} content preview:`, file.args.fileContent.substring(0, 100));
                });
                
                // Create a map of files for our virtual file system
                const virtualFileSystem = {};
                jsxFiles.forEach(file => {
                    // Modify the SomeComponent export to not use window
                    if (file.args.filePath.includes('someComponent.jsx')) {
                        const content = file.args.fileContent.replace(
                            "// Export for use in other files\nwindow.SomeComponent = SomeComponent;", 
                            "export default SomeComponent;"
                        );
                        virtualFileSystem[file.args.filePath] = content;
                    } else {
                        virtualFileSystem[file.args.filePath] = file.args.fileContent;
                    }
                });
                
                console.log("Virtual file system created with files:", Object.keys(virtualFileSystem));
                
                // Find the entry point (index.jsx)
                const entryPoint = jsxFiles.find(file => file.args.filePath.endsWith('index.jsx'))?.args.filePath;
                
                if (!entryPoint) {
                    throw new Error("No index.jsx entry point found");
                }
                
                console.log(`Using entry point: ${entryPoint}`);
                
                // Create a plugin to resolve imports from our virtual file system
                const virtualFsPlugin = {
                    name: 'virtual-fs',
                    setup(build) {
                        // Handle all file resolution
                        build.onResolve({ filter: /.*/ }, args => {
                            if (args.kind === 'entry-point') {
                                return { path: args.path, namespace: 'virtual-fs' };
                            }
                            
                            // Handle relative imports
                            if (args.path.startsWith('./') || args.path.startsWith('../')) {
                                let normalizedPath = args.path;
                                let resolveDir = args.resolveDir || '';
                                
                                // Handle parent directory paths (../)
                                if (normalizedPath.startsWith('../')) {
                                    // Split resolveDir into parts
                                    const resolveParts = resolveDir.split('/');
                                    // Remove the last part to go up one directory
                                    resolveParts.pop();
                                    resolveDir = resolveParts.join('/');
                                    // Remove ../ from the beginning
                                    normalizedPath = normalizedPath.substring(3);
                                }
                                // Handle current directory paths (./)
                                else if (normalizedPath.startsWith('./')) {
                                    normalizedPath = normalizedPath.substring(2);
                                }
                                
                                // Construct the full path
                                const basePath = resolveDir ? `${resolveDir}/` : '';
                                const fullPath = `${basePath}${normalizedPath}`;
                                
                                console.log("Resolving path:", args.path, "from dir:", resolveDir, "to:", fullPath);
                                
                                // Check if the file exists in our virtual file system
                                const possiblePaths = [
                                    fullPath,
                                    `${fullPath}.jsx`,
                                    `${fullPath}.js`,
                                    // Handle CSS imports
                                    normalizedPath,
                                    `${normalizedPath}.js`
                                ];
                                
                                for (const path of possiblePaths) {
                                    if (virtualFileSystem[path]) {
                                        return { path, namespace: 'virtual-fs' };
                                    }
                                }
                                
                                console.warn(`Could not resolve: ${args.path} from ${resolveDir}`);
                            }
                            
                            // Pass through external dependencies (like React)
                            return { path: args.path, external: true };
                        });
                        
                        // Load files from virtual file system
                        build.onLoad({ filter: /.*/, namespace: 'virtual-fs' }, args => {
                            const fileContent = virtualFileSystem[args.path];
                            
                            if (fileContent) {
                                // Determine loader based on file extension
                                const loader = args.path.endsWith('.css') ? 'css' : 'jsx';
                                const resolveDir = args.path.split('/').slice(0, -1).join('/');
                                
                                return { 
                                    contents: fileContent, 
                                    loader, 
                                    resolveDir 
                                };
                            }
                            
                            return null;
                        });
                    }
                };
                
                // Bundle the application
                console.log("Starting bundle process...");
                
                // Handle CSS imports to prevent esbuild errors
                try {
                    if (virtualFileSystem[entryPoint]) {
                        console.log("Processing entry point for CSS imports");
                        const indexContent = virtualFileSystem[entryPoint];
                        
                        // Replace any CSS/style imports with comments
                        const modifiedContent = indexContent
                            .replace(/import\s+['"]\.\/(styles|css)\/.*?['"];?\s*/g, '// CSS styles are loaded separately\n')
                            .replace(/import\s+['"]\.\.\/styles\/.*?['"];?\s*/g, '// CSS styles are loaded separately\n');
                        
                        // Log what changed
                        if (modifiedContent !== indexContent) {
                            console.log("Removed CSS imports from entry point");
                        } else {
                            console.log("No CSS imports found in entry point");
                        }
                        
                        virtualFileSystem[entryPoint] = modifiedContent;
                    }
                } catch (err) {
                    console.warn("Error processing CSS imports:", err);
                    // Continue anyway - CSS is loaded separately
                }

                let result;
                try {
                    console.log('Running initial build with format: esm');
                    result = await esbuild.build({
                        entryPoints: [entryPoint],
                        bundle: true,
                        format: 'esm',  // ES modules format to work with import map
                        jsx: 'transform',
                        jsxFactory: 'React.createElement',
                        jsxFragment: 'React.Fragment',
                        plugins: [virtualFsPlugin],
                        define: {
                            'process.env.NODE_ENV': '"development"'
                        },
                        external: ['*.css', '*.scss', 'react', 'react-dom', 'react-dom/client', 'styled-components', '@zendeskgarden/*'],  // Use CDN imports
                        write: false, // Output to memory
                        logLevel: 'info'
                    });
                } catch (buildError) {
                    console.error("esbuild build failed:", buildError);
                    
                    // Try a simpler approach as fallback
                    console.log("Attempting fallback build without CSS imports...");
                    
                    // Additional cleanup of problematic imports in all files
                    Object.keys(virtualFileSystem).forEach(key => {
                        virtualFileSystem[key] = virtualFileSystem[key].replace(
                            /import\s+['"].*?\.(css|scss|less|styles)['"];?\s*/g,
                            '// CSS import removed\n'
                        );
                    });
                    
                    // Try again with the cleaned files
                    console.log('Running fallback build with format: esm');
                    result = await esbuild.build({
                        entryPoints: [entryPoint],
                        bundle: true,
                        format: 'esm',  // ES modules format to work with import map
                        jsx: 'transform',
                        jsxFactory: 'React.createElement',
                        jsxFragment: 'React.Fragment',
                        plugins: [virtualFsPlugin],
                        define: {
                            'process.env.NODE_ENV': '"development"'
                        },
                        external: ['*.css', '*.scss', '*.styles.js', 'react', 'react-dom', 'react-dom/client', 'styled-components', '@zendeskgarden/*'],
                        write: false
                    });
                }
                
                console.log("Bundle completed successfully");
                
                if (result.errors.length > 0) {
                    console.error("Build errors:", result.errors);
                    throw new Error(`Build failed with ${result.errors.length} errors`);
                }
                
                if (result.warnings.length > 0) {
                    console.warn("Build warnings:", result.warnings);
                }
                
                // Execute the bundled code
                const bundledCode = result.outputFiles[0].text;
                console.log("Bundled code size:", bundledCode.length, "bytes");
                
                // Add error handlers to debug React rendering issues
                window.addEventListener('error', function(event) {
                    console.error('Global error caught:', event.error);
                    const debugInfo = document.getElementById('debug-info');
                    if (debugInfo) {
                        debugInfo.textContent = 'Error: ' + (event.error?.message || event.message || 'Unknown error');
                    }
                });
                
                window.addEventListener('unhandledrejection', function(event) {
                    console.error('Unhandled promise rejection:', event.reason);
                    const debugInfo = document.getElementById('debug-info');
                    if (debugInfo) {
                        debugInfo.textContent = 'Promise error: ' + (event.reason?.message || 'Unknown promise error');
                    }
                });
                
                // Execute the bundled code
                try {
                    // Create a blob URL for the bundled code
                    const bundleBlob = new Blob([bundledCode], { type: 'text/javascript' });
                    const bundleUrl = URL.createObjectURL(bundleBlob);
                    
                    console.log("Bundle URL created:", bundleUrl);
                    
                    // Create and execute module script to import the app
                    try {
                        const moduleScript = document.createElement('script');
                        moduleScript.type = 'module';
                        // Reset the root element to make sure we see the loading state
                        document.getElementById('root').innerHTML = '<div class="loading">Loading application... <div id="debug-info" style="color: #999; font-size: 12px; margin-top: 10px;">Starting to load components...</div></div>';
                        
                        moduleScript.textContent = `
                            // Debug imports
                            console.log('Import map available:', Object.keys(Array.from(document.querySelectorAll('script[type="importmap"]')).map(s => JSON.parse(s.textContent).imports || {}).reduce((acc, imports) => ({ ...acc, ...imports }), {})));
                            
                            // Wait for Garden components to download before loading the app
                            document.getElementById('debug-info').textContent = 'Waiting for Zendesk Garden components to load (5 seconds)...';
                            
                            // Pre-fetch Zendesk Garden Button to ensure it's downloaded
                            console.log('Pre-fetching Garden Button component...');
                            import('@zendeskgarden/react-buttons')
                                .then(gardenButtons => {
                                    console.log('Successfully pre-fetched Zendesk Garden components:', gardenButtons);
                                })
                                .catch(err => {
                                    console.error('Error pre-fetching Garden components:', err);
                                });
                            
                            // Delay app loading to ensure Garden components are downloaded
                            setTimeout(() => {
                                document.getElementById('debug-info').textContent = 'Loading app after Garden components delay...';
                                
                                import('${bundleUrl}')
                                    .then(module => {
                                        document.getElementById('debug-info').textContent = 'Module loaded, looking for App component...';
                                        console.log('Module loaded:', module);
                                        
                                        const App = module.default || module;
                                        console.log('App component:', App);
                                        
                                        if (typeof App !== 'function') {
                                            document.getElementById('debug-info').textContent = 'Error: App is not a component function';
                                            console.error('App is not a component function:', App);
                                            return;
                                        }
                                        
                                        document.getElementById('debug-info').textContent = 'Found App, attempting to render...';
                                        const root = ReactDOM.createRoot(document.getElementById('root'));
                                        
                                        try {
                                            console.log('About to render App');
                                            root.render(React.createElement(App));
                                            console.log('Render completed');
                                            document.getElementById('debug-info').textContent = 'App rendered successfully';
                                            // Force full reload of styles
                                            document.getElementById('root').style.opacity = '0';
                                            setTimeout(() => {
                                                document.getElementById('root').style.opacity = '1';
                                            }, 100);
                                        } catch(e) {
                                            document.getElementById('debug-info').textContent = 'Error rendering: ' + e.message;
                                            console.error('Render error:', e);
                                        }
                                    })
                                    .catch(error => {
                                        document.getElementById('debug-info').textContent = 'Import error: ' + error.message;
                                        console.error('Import error:', error);
                                    });
                            }, 5000); // 5 second delay
                        `;
                        
                        // Add the module script to the document
                        document.body.appendChild(moduleScript);
                        console.log("Module script created and executed");
                    } catch (moduleError) {
                        console.error("Error creating module script:", moduleError);
                        
                        // Fallback to legacy approach
                        console.log("Falling back to direct component rendering");
                        
                        const root = ReactDOM.createRoot(document.getElementById('root'));
                        
                        if (window.App) {
                            console.log("Rendering App component");
                            root.render(React.createElement(window.App));
                        } else {
                            // Look for any React component in the global namespace
                            const components = Object.keys(window).filter(key => {
                                return typeof window[key] === 'function' &&
                                       key !== 'React' &&
                                       key !== 'ReactDOM' &&
                                       !key.startsWith('_');
                            });
                            
                            if (components.length > 0) {
                                const componentName = components[0];
                                console.log(`Found component ${componentName}. Rendering...`);
                                root.render(React.createElement(window[componentName]));
                            } else {
                                throw new Error("No React component found to render");
                            }
                        }
                        
                        console.log("App mounted successfully");
                    }
                } catch (error) {
                    console.error("Error executing bundle:", error);
                    throw error;
                }
                
            } catch (error) {
                console.error("Error during bundling or rendering:", error);
                document.getElementById('root').innerHTML = `
                    <div class="error">
                        <h3>Error in Application</h3>
                        <p>${error.message}</p>
                        <pre style="background: #f8f9fa; padding: 10px; overflow: auto; max-height: 300px;">${error.stack}</pre>
                    </div>
                `;
            }
        }
        
        // Register the message listener
        window.addEventListener('message', handleMessage);
        
        // Let parent know we're ready to receive messages
        console.log("Message listener registered. Waiting for data via window.postMessage()");
        
        // Test message handler with mock data
        if (window.location.search.includes('debug=true')) {
            console.log("Debug mode: Sending test message");
            // For debugging purposes only - simulate message from parent
            const testEvent = {
                data: {
                    type: "data",
                    data: {
                        output: [{
                            args: {
                                filePath: "mock.js",
                                fileContent: "console.log('Mock data loaded'); window.mockZafClient = {get: () => Promise.resolve({currentUser: {name: 'Test User'}})};"
                            }
                        }]
                    }
                }
            };
            setTimeout(() => handleMessage(testEvent), 1000);
        }
    </script>
</body>
</html>